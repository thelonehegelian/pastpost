import { NextApiRequest } from 'next';
import lighthouse from '@lighthouse-web3/sdk';
import path from 'path';

// @note folder cannot be empty
const uploadPath = `${path.join(process.cwd(), 'uploadDir')}/cat.jpeg`;

const API_KEY = 'de1443ca.854cd879e421475f935d4e74126035f7';
export async function POST(req: Request) {
  const sigs = await req.json();
  const [sig1, sig2] = sigs;
  const publicKey = sig2.publicKey;
  const sigForEncryption = sig2.signedMessage;
  const sigForAccess = sig1.signedMessage;
  // const uploadFile = async () => {
  //   const path = uploadPath; // Provide the path to the file
  //   const apiKey = API_KEY;
  //   // Generate the API key from https://files.lighthouse.storage/
  //   //or using CLI (lighthouse-web3 api-key --new)

  //   // Both files and folders are supported by the upload function
  //   const response = await lighthouse.upload(path, apiKey);

  //   console.log(response);
  //   console.log('Visit at: https://gateway.lighthouse.storage/ipfs/' + response.data.Hash);
  //   return response;
  // };

  // const uploadFileRes = await uploadFile();
  // console.log(uploadFileRes.data.Hash);
  const deployEncrypted = async (_filePath, _publiKey, _signedMessage) => {
    const uploadResponse = await lighthouse.uploadEncrypted(
      _filePath,
      API_KEY,
      _publiKey,
      _signedMessage,
    );
    // console.log(uploadResponse);
    return uploadResponse;
  };

  const deployEncryptedResponse = await deployEncrypted(uploadPath, publicKey, sigForEncryption);
  console.log(deployEncryptedResponse);
  const data_id = deployEncryptedResponse.data[0].Hash;
  console.log(data_id);
  // console.log(deployEncryptedResponse.data);
  // // TODO create NFT and get back the NFT address, maybe do this on the frontend? with 1. "Mint TimeCapsule" 2. "Finalize Time Capsule" 3. "See Time Capsule"

  interface AccessConditions {
    id: number;
    chain: string;
    method: string;
    standardContractType: string;
    returnValueTest: {
      comparator: string;
      value: string;
    };
  }

  //       // NFT based access condition
  const nftAccessConditions = {
    id: 1,
    chain: 'Calibration',
    method: 'balanceOf',
    standardContractType: 'ERC721',
    contractAddress: '0xd9145CCE52D386f254917e481eB44e9943F39138',
    returnValueTest: { comparator: '>=', value: '1' },
    parameters: [':userAddress'],
  };

  //       const timeAccessConditions = { id: 1,
  //         chain: "Optimism",
  //         method: "getBlockNumber",
  //         standardContractType: "",
  //         returnValueTest: {
  //             comparator: ">",
  //                 value: "133493"
  //          },};
  const accessControl = async () => {
    try {
      // CID on which you are applying encryption
      // CID is generated by uploading a file with encryption
      // Only the owner of the file can apply access conditions

      // Conditions to add
      const conditions = [
        {
          id: 1,
          chain: 'Optimism',
          method: 'getBlockNumber',
          standardContractType: '',
          returnValueTest: {
            comparator: '>=',
            value: '13349',
          },
        },
      ];

      // Aggregator is what kind of operation to apply to access conditions
      // Suppose there are two conditions then you can apply ([1] and [2]), ([1] or [2]), !([1] and [2]).
      const aggregator = '([1])';

      /*
      accessCondition(publicKey, cid, signedMessage, conditions, aggregator)
        Parameters:
          publicKey: owner's public key
          CID: CID of the file to apply access control on
          signedMessage: message signed by the owner of publicKey
          conditions: access conditions in the specified format
          aggregator: aggregator to apply conditions
    */
      const response = await lighthouse.applyAccessCondition(
        publicKey,
        data_id,
        sigForAccess,
        conditions,
        aggregator,
      );

      // Display response
      console.log(response);
    } catch (error) {
      console.log(error);
    }
  };

  await accessControl();
  return new Response('Access Control');
}
